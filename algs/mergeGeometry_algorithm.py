# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LightPollutionToolbox
                                 A QGIS plugin
 Light pollution indicators (focus on public lighting)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-04-20
        copyright            : (C) 2020 by Mathieu Chailloux
        email                : mathieu@chailloux.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Mathieu Chailloux'
__date__ = '2020-04-20'
__copyright__ = '(C) 2020 by Mathieu Chailloux'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from PyQt5.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingUtils,
                       QgsProcessingException,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterCrs,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterVectorDestination,
                       QgsCoordinateReferenceSystem,
                       QgsCoordinateTransform,
                       QgsCoordinateTransformContext,
                       QgsGeometry,
                       QgsFields,
                       QgsFeature,
                       QgsFeatureSink,
                       QgsWkbTypes)

from ..qgis_lib_mc import utils, qgsUtils, qgsTreatments

class MergeGeometryAlgorithm(QgsProcessingAlgorithm):
    
    OUTPUT = 'OUTPUT'
    LAYERS = 'LAYERS'
    CRS = 'CRS'
    
    DEFAULT_CRS = QgsCoordinateReferenceSystem("epsg:2154")
    
    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.LAYERS,
                self.tr('Layers')))
        self.addParameter(
            QgsProcessingParameterCrs(
                self.CRS,
                description=self.tr("Output CRS"),
                defaultValue=self.DEFAULT_CRS))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')))

    def processAlgorithm(self, parameters, context, feedback):
        layers = self.parameterAsLayerList(parameters,self.LAYERS,context)
        dest_crs = self.parameterAsCrs(parameters,self.CRS,context)
        
        out_fields = QgsFields()
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                context, out_fields, QgsWkbTypes.MultiPolygon, dest_crs)
                
        nb_feats = 0
        for layer in layers:
            nb_feats += layer.featureCount()
        total = 100.0 / nb_feats if nb_feats else 0
        curr = 0
                
        for layer in layers:
            layer_crs = layer.sourceCrs()
            if layer_crs == dest_crs:
                transformator = None
            else:
                trContext = QgsCoordinateTransformContext()
                transformator = QgsCoordinateTransform(layer_crs,dest_crs,trContext)
            for feat in layer.getFeatures():
                feat_geom = QgsGeometry(feat.geometry())
                if feat_geom.isEmpty():
                    continue
                feat_geom.convertToMultiType()
                if transformator:
                    feat_geom.transform(transformator)
                new_feat = QgsFeature(out_fields)
                new_feat.setGeometry(feat_geom)
                sink.addFeature(new_feat, QgsFeatureSink.FastInsert)
                curr += 1
                feedback.setProgress(int(curr * total))
                
        return {self.OUTPUT: dest_id}
        
    def name(self):
        return 'Merge geometries'

    def displayName(self):
        return self.tr(self.name())

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return MergeGeometryAlgorithm()
                
                