# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LightPollutionToolbox
                                 A QGIS plugin
 Light pollution indicators (focus on public lighting)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-04-20
        copyright            : (C) 2020 by Mathieu Chailloux
        email                : mathieu@chailloux.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Mathieu Chailloux'
__date__ = '2020-04-20'
__copyright__ = '(C) 2020 by Mathieu Chailloux'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from PyQt5.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsFeatureRequest,
                       QgsFeature,
                       QgsProject,
                       QgsProcessingUtils,
                       QgsProcessingContext,
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingException,
                       QgsProcessingAlgorithm,
                       QgsProcessingFeatureSourceDefinition,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterField,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterVectorDestination,
                       QgsFields,
                       QgsField)

from ..qgis_lib_mc import utils, qgsUtils, qgsTreatments, styles


class FluxDenGrpAlg(QgsProcessingAlgorithm):

    INPUT = 'INPUT'
    OUTPUT = 'OUTPUT'
    FLUX_DEN = 'FLUX_DEN'

    def displayName(self):
        return self.tr(self.name())

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def group(self):
        return self.tr('Light Flux Surfacic Density')
        
    def groupId(self):
        return self.tr('density')

    

class FluxDensityAlgorithm(FluxDenGrpAlg):

    LIGHTING = 'LIGHTING'
    FLUX_FIELD = 'FLUX_FIELD'
    REPORTING = 'REPORTING'
    SURFACE = 'SURFACE'
    DISSOLVE = 'DISSOLVE'
    CLIP_DISTANCE = 'CLIP_DISTANCE'
    REPORTING_FIELDS = 'REPORTING_FIELDS'
    SKIP_EMPTY = 'SKIP_EMPTY'
    MIN_AREA = 'MIN_AREA'
    MIN_NB_LAMPS= 'MIN_NB_LAMPS'
    
    SURFACE_AREA = 'SURFACE'
    NB_LAMPS = 'NB_LAMPS'
    FLUX_SUM = 'FLUX_SUM'

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LIGHTING,
                self.tr('Lighting layer'),
                [QgsProcessing.TypeVectorPoint]))
        self.addParameter(
            QgsProcessingParameterField(
                self.FLUX_FIELD,
                description=self.tr('Light flux field'),
                defaultValue='flux',
                type=QgsProcessingParameterField.Numeric,
                parentLayerParameterName=self.LIGHTING))
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.REPORTING,
                self.tr('Reporting layer'),
                [QgsProcessing.TypeVectorPolygon]))
        self.addParameter(
            QgsProcessingParameterNumber(
                self.CLIP_DISTANCE,
                self.tr("Maximal distance to lighting layer (reporting layer clip)"),
                type=QgsProcessingParameterNumber.Double,
                optional=True))
        self.addParameter(
            QgsProcessingParameterField(
                self.REPORTING_FIELDS,
                self.tr("Reporting fields to keep in output layer"),
                parentLayerParameterName=self.REPORTING,
                allowMultiple=True,
                optional=True))
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.SURFACE,
                self.tr('Surface to be illuminated layer'),
                [QgsProcessing.TypeVectorPolygon],
                optional=True))
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.DISSOLVE,
                self.tr('Dissolve surface layer (no overlapping features)'),
                defaultValue=False))
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.SKIP_EMPTY,
                self.tr('Skip features with empty flux'),
                defaultValue=False))
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MIN_AREA,
                self.tr("Features minimal area (smaller features are skipped)"),
                type=QgsProcessingParameterNumber.Double,
                optional=True))
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MIN_NB_LAMPS,
                self.tr("Minimal number of lamps (features with less lamps are skipped)"),
                type=QgsProcessingParameterNumber.Integer,
                optional=True))

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')))

    def processAlgorithm(self, parameters, context, feedback):
        self.dest_id = None
        # Parameters
        # lighting = self.parameterAsVectorLayer(parameters, self.LIGHTING, context)
        lighting = self.parameterAsSource(parameters, self.LIGHTING, context)
        if not lighting:
            raise QgsProcessingException("No lighting layer")
        lighting_layer = lighting.materialize(QgsFeatureRequest(),feedback=feedback)
        fieldname = self.parameterAsString(parameters,self.FLUX_FIELD,context)
        if not fieldname:
            raise QgsProcessingException("No field given for light flux")
        # reporting = self.parameterAsVectorLayer(parameters, self.REPORTING, context)
        reporting = self.parameterAsSource(parameters, self.REPORTING, context)
        if not reporting:
            raise QgsProcessingException("No reporting layer")
        reporting_layer = reporting.materialize(QgsFeatureRequest(),feedback=feedback)
        surface = self.parameterAsSource(parameters, self.SURFACE, context)
        dissolve_flag = self.parameterAsBool(parameters,self.DISSOLVE,context)
        clip_val = self.parameterAsInt(parameters,self.CLIP_DISTANCE,context)
        reporting_fields = self.parameterAsFields(parameters,self.REPORTING_FIELDS,context)
        skip_flag = self.parameterAsBool(parameters,self.SKIP_EMPTY,context)
        min_area = self.parameterAsDouble(parameters,self.MIN_AREA,context)
        min_lamps = self.parameterAsInt(parameters,self.MIN_NB_LAMPS,context)
        
        # Reprojection if needed
        light_crs = lighting.sourceCrs().authid()
        reporting_crs = reporting.sourceCrs()
        # reporting_crs = reporting.dataProvider().sourceCrs()
        if reporting_crs.isGeographic():
            raise QgsProcessingException("Reporting CRS must be a projection (not lat/lon)")
        reporting_crs = reporting_crs.authid()
        if light_crs != reporting_crs:
            #feedback.pushDebugInfo("lightin type " + str(lighting_layer.__type__))
            lighting_path = QgsProcessingUtils.generateTempFilename('light_reproj.gpkg')
            qgsTreatments.applyReprojectLayer(lighting_layer,reporting_crs,lighting_path,
                context=context,feedback=feedback)
            lighting_layer = lighting_path
        if surface:
            surface_layer = surface.materialize(QgsFeatureRequest(),feedback=feedback)
            surface_crs = surface.sourceCrs().authid()
            if reporting_crs != surface_crs:
                surface_path = QgsProcessingUtils.generateTempFilename('surface_reproj.gpkg')
                qgsTreatments.applyReprojectLayer(surface_layer,reporting_crs,surface_path,
                    context=context,feedback=feedback)
                surface = surface_path
                
        # Output fields initialization
        nb_lamps_field = QgsField(self.NB_LAMPS, QVariant.Int)
        flux_sum_field = QgsField(self.FLUX_SUM, QVariant.Double)
        surface_field = QgsField(self.SURFACE_AREA, QVariant.Double)
        flux_den_field = QgsField(self.FLUX_DEN, QVariant.Double)
        out_fields = QgsFields()
        for f in reporting_layer.fields():
            if f.name() in reporting_fields:
                # feedback.pushDebugInfo("f2 = " + str( f.name()))
                out_fields.append(f)
        out_fields.append(nb_lamps_field)
        out_fields.append(flux_sum_field)
        out_fields.append(surface_field)
        out_fields.append(flux_den_field)
        (sink, self.dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                context, out_fields, reporting.wkbType(), reporting.sourceCrs())

        # Progess bar step
        nb_feats = reporting.featureCount()
        total = 100.0 / nb_feats if nb_feats else 0
        
        # Clip according to distance to lighting
        if clip_val:
            buffered_path = QgsProcessingUtils.generateTempFilename('light_buf.gpkg')
            buffered = qgsTreatments.applyBufferFromExpr(lighting_layer,clip_val,
                buffered_path,context=context,feedback=feedback)
            clipped_path = QgsProcessingUtils.generateTempFilename('reporting_clip.gpkg')
            qgsTreatments.createSpatialIndex(reporting_layer,context=context,feedback=feedback)
            clipped = qgsTreatments.applyVectorClip(reporting_layer,buffered_path,
                clipped_path,context=context,feedback=feedback)
            reporting_layer = clipped_path
        
        # Join light points summary by reporting unit
        joined_path = QgsProcessingUtils.generateTempFilename('joined.gpkg')
        # SUM = 5
        summaries = [0,1,2,3,5,6]
        # reporting_def = QgsProcessingFeatureSourceDefinition(reporting_layer.)
        qgsTreatments.createSpatialIndex(reporting_layer,context=context,feedback=feedback)
        joined = qgsTreatments.joinByLocSummary(reporting_layer,lighting_layer,joined_path,
            [fieldname],summaries,predicates=[0],context=context,feedback=feedback)
        joined_layer = qgsUtils.loadVectorLayer(joined_path)
        nb_lamps_fieldname = fieldname + "_count"
        flux_field_sum = fieldname + "_sum"
        
        # Set context and feedback
        if not context:
            context = QgsProcessingContext()
        context = context.setInvalidGeometryCheck(QgsFeatureRequest.GeometryNoCheck)
        multi_feedback = QgsProcessingMultiStepFeedback(nb_feats,feedback)
        
        # Iteration on each reporting unit
        qgsTreatments.createSpatialIndex(joined_layer,context=context,feedback=feedback)
        for current, feat in enumerate(joined_layer.getFeatures()):
            if feedback.isCanceled():
                break
            f_geom = feat.geometry()
            f_area = f_geom.area()
            f_id = feat.id()
            nb_lamps = feat[nb_lamps_fieldname]
            flux_sum = feat[flux_field_sum]
            if skip_flag and flux_sum == 0:
                continue
            if f_area < min_area:
                continue
            if nb_lamps < min_lamps:
                continue
            
            try:
                if surface:
                    # Clip surface layer to reporting feature boundaries to retrieve intersecting area
                    nb_steps = 4 if dissolve_flag else 3
                    mmf = QgsProcessingMultiStepFeedback(nb_steps,multi_feedback)
                    joined_layer.selectByIds([f_id])
                    suffix = "_" + str(f_id) + ".gpkg"
                    input_feat = QgsProcessingUtils.generateTempFilename("selection" + suffix)
                    qgsTreatments.saveSelectedAttributes(joined_layer,
                        input_feat,context=context,feedback=mmf)
                    mmf.setCurrentStep(1)
                    # input_feat = QgsProcessingFeatureSourceDefinition(joined_layer.id(),True)
                    clipped_path = QgsProcessingUtils.generateTempFilename("clipped"
                        + str(f_id) + ".gpkg")
                    clipped = qgsTreatments.applyVectorClip(surface_layer,input_feat,
                        clipped_path,context=context,feedback=mmf)
                    mmf.setCurrentStep(2)
                    if dissolve_flag:
                        feat_surface_path = QgsProcessingUtils.generateTempFilename(
                            "dissolved" + str(f_id) + ".gpkg")
                        qgsTreatments.dissolveLayer(clipped,feat_surface_path,context=context,feedback=mmf)
                        mmf.setCurrentStep(3)
                    else:
                        feat_surface_path = clipped_path
                    feat_surface_layer = qgsUtils.loadVectorLayer(feat_surface_path)
                    # clipped_layer = qgsUtils.loadVectorLayer(clipped_path)
                    joined_layer.removeSelection()
                    
                    surface_area = 0
                    for surface_feat in feat_surface_layer.getFeatures():
                        surface_geom = surface_feat.geometry()
                        intersection = f_geom.intersection(surface_geom)
                        surface_area += intersection.area()
                    mmf.setCurrentStep(nb_steps)
                else:
                    surface_area = f_area
                    
                # Output result feature
                new_feat = QgsFeature(out_fields)
                new_feat.setGeometry(feat.geometry())
                #flux_sum = feat[flux_field_sum]
                for report_field in reporting_fields:
                    new_feat[report_field] = feat[report_field]
                new_feat[self.NB_LAMPS] = nb_lamps
                new_feat[self.FLUX_SUM] = flux_sum
                new_feat[self.SURFACE_AREA] = surface_area
                new_feat[self.FLUX_DEN] = flux_sum / surface_area if surface_area > 0 else None
                sink.addFeature(new_feat, QgsFeatureSink.FastInsert)
            except Exception as e:
                feedback.reportError('Unexpected error : ' + str(e))
                raise e
                
            multi_feedback.setCurrentStep(current + 1)
        
        return {self.OUTPUT: self.dest_id }
            
    def postProcessAlgorithm(self,context,feedback):
        # out_layer = QgsProject.instance().mapLayer(self.dest_id)
        out_layer = QgsProcessingUtils.mapLayerFromString(self.dest_id,context)
        if not out_layer:
            raise QgsProcessingException("No layer found for " + str(self.dest_id))
        styles.setCustomClassesDSFL(out_layer,self.FLUX_DEN)
        return {self.OUTPUT: self.dest_id }
        
            
    def name(self):
        return 'Light Flux Surfacic Density'
        
    def shortHelpString(self):
        helpStr = "Estimation of light flux density.\n"
        helpStr += " Flux value is selected from lighting layer according to light flux field.\n"
        helpStr += " Surface to be illuminated (roads, sidewalks, parking areas, ...) can be specified"
        helpStr += " through a polygon layer.\n"
        helpStr += " For each entity of reporting layer, flux light points inside entity are selected."
        return self.tr()

    def createInstance(self):
        return FluxDensityAlgorithm()
        
        

class DSFLSymbology(FluxDenGrpAlg):

    DSFL_FIELD = 'DSFL_FIELD'

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterField(
                self.DSFL_FIELD,
                self.tr('DSFL field'),
                defaultValue=self.FLUX_DEN,
                parentLayerParameterName=self.INPUT))

        # self.addParameter(
            # QgsProcessingParameterFeatureSink(
                # self.OUTPUT,
                # self.tr('Output layer')))
    
    
    def processAlgorithm(self, parameters, context, feedback):
        self.in_layer = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        self.dsfl_field = self.parameterAsString(parameters,self.DSFL_FIELD,context)
        if not self.in_layer:
            raise QgsProcessingException("No input layer")
        return { self.OUTPUT : None }
        
    
    def postProcessAlgorithm(self,context,feedback):
        if not self.in_layer:
            raise QgsProcessingException("No DSFL layer")
        styles.setCustomClassesDSFL(self.in_layer,self.dsfl_field)
        return { self.OUTPUT : None }
        
    def name(self):
        return 'Apply symbology to DSFL layer'
        
    def shortHelpString(self):
        helpStr = "Apply symbology to DSFL layer"
        return self.tr()

    def createInstance(self):
        return DSFLSymbology()
        
